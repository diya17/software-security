# -*- coding: utf-8 -*-
"""Classification of Benign and malicious apps.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OJQJK1M9--5KwxqC5o7oxbjBIKhoH1rW
"""

#from google.colab import drive
#import pathlib
#drive.mount('/content/drive',force_remount=True)

import os
import shutil
import pandas as pd
from sklearn.preprocessing import MultiLabelBinarizer
import xml.etree.ElementTree as ET
import sklearn.svm
import sklearn.cluster
import sklearn.linear_model
import sklearn.model_selection
import sklearn.tree
import lightgbm
import sklearn.metrics
import xgboost
from sklearn.decomposition import PCA
import matplotlib.pyplot
import numpy as np
import sklearn.ensemble
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis

seed = 17

def parseAndDecompileApks(filePath,chdirectory):
    apkTool = "C:/Users/jnoronha/apktool.jar"
    for fileName in os.listdir(filePath):
        curFilePath = os.path.join(filePath, fileName)
        os.chdir(chdirectory)
        if curFilePath.endswith('.apk'):
            os.system("java -jar " + apkTool + " d " + curFilePath)


def parseAndGetAndroidManifest(directoryPath, outputPath):
    for directory in os.listdir(directoryPath):
        if directory == '.DS_Store':
            continue
        inputFilePath = '/'+directory+'/AndroidManifest.xml'
        outputFileName = '/'+directory+'_AndroidManifest.xml'
        if(os.path.exists(directoryPath+inputFilePath)):
          shutil.copyfile(directoryPath+inputFilePath, outputPath+outputFileName)

def calculatefscore(expected,actual):
  TP=0
  FP=0
  FN=0
  TN=0
  for i in range(len(expected)):
    if actual[i]>=1 and expected[i]==1:
      TP=TP+1
    elif actual[i]==1 and expected[i]==0:
      FP=FP+1
    elif actual[i]==0 and expected[i]==1:
      FN=FN+1
    else:
      TN=TN+1
  print(TP,FP,FN,TN)

parseAndDecompileApks('C:/Users/jnoronha/Documents/siftwaresecurity/malware','C:/Users/jnoronha/Documents/siftwaresecurity/extractedmalware')
parseAndDecompileApks('C:/Users/jnoronha/Documents/siftwaresecurity/benign','C:/Users/jnoronha/Documents/siftwaresecurity/extractedbenign')
parseAndGetAndroidManifest('C:/Users/jnoronha/Documents/siftwaresecurity/extractedmalware', 'C:/Users/jnoronha/Documents/siftwaresecurity/extractedmanifestmalign')
parseAndGetAndroidManifest('C:/Users/jnoronha/Documents/siftwaresecurity/extractedbenign', 'C:/Users/jnoronha/Documents/siftwaresecurity/extractedmanifestbenign')

malPermissionsMapFeat1 = pd.DataFrame(columns=['AppName','Permissions','Receiver','isBenign'])

mal_dir = "/content/drive/MyDrive/extractedmanifestmalign"
for fileName in os.listdir(mal_dir):
  if fileName == '.DS_Store':
    continue
  androidManifest = ET.parse(mal_dir+'/'+fileName)
  appName = fileName[:len(fileName)-20]
  permissionsList = []
  receiverList= []
  for permission in androidManifest.findall('uses-permission'):
    permissionsList.append(permission.attrib['{http://schemas.android.com/apk/res/android}name'])
  for receiver in androidManifest.findall('application/receiver'):
    receiverList.append(receiver.attrib['{http://schemas.android.com/apk/res/android}name'])
  malPermissionsMapFeat1.loc[len(malPermissionsMapFeat1.index)] = [appName,permissionsList,receiverList,0]

benPermissionsMapFeat1 = pd.DataFrame(columns=['AppName','Permissions','Receiver','isBenign'])

ben_dir = "/content/drive/My Drive/extractedmanifestbenign"
for fileName in os.listdir(ben_dir):
  if fileName == '.DS_Store':
    continue
  androidManifest = ET.parse(ben_dir+'/'+fileName)
  appName = fileName[:len(fileName)-20]
  permissionsList = []
  receiverList= []
  for permission in androidManifest.findall('uses-permission'):
    permissionsList.append(permission.attrib['{http://schemas.android.com/apk/res/android}name'])
  for receiver in androidManifest.findall('application/receiver'):
    receiverList.append(receiver.attrib['{http://schemas.android.com/apk/res/android}name'])
  benPermissionsMapFeat1.loc[len(benPermissionsMapFeat1.index)] = [appName,permissionsList,receiverList,1]
permissionsMapFeat1=pd.concat([benPermissionsMapFeat1,malPermissionsMapFeat1],ignore_index=True)

multiLableBinarizer = MultiLabelBinarizer(sparse_output=True)
permissionsMapFeat1 = permissionsMapFeat1.join(pd.DataFrame.sparse.from_spmatrix(multiLableBinarizer.fit_transform(permissionsMapFeat1.pop('Permissions')),index=permissionsMapFeat1.index,columns=multiLableBinarizer.classes_))
permissionsMapFeat1 = permissionsMapFeat1.join(pd.DataFrame.sparse.from_spmatrix(multiLableBinarizer.fit_transform(permissionsMapFeat1.pop('Receiver')),index=permissionsMapFeat1.index,columns=multiLableBinarizer.classes_))
permissionsMapFeat1 = permissionsMapFeat1.drop('AppName', axis=1)
isBenFeat1=permissionsMapFeat1.isBenign
permissionsMapFeat1 = permissionsMapFeat1.drop('isBenign', axis=1)
permissionsMapFeat1=permissionsMapFeat1.to_numpy()
isBenFeat1=isBenFeat1.to_numpy()

trainSet,testSet,trainRes,testRes = sklearn.model_selection.train_test_split(permissionsMapFeat1,isBenFeat1, test_size=0.2, random_state=17)
n_components = 10

pca = PCA(n_components=n_components).fit(trainSet)
matplotlib.pyplot.plot(np.cumsum(pca.explained_variance_ratio_))
np.cumsum(pca.explained_variance_ratio_)
matplotlib.pyplot.xlabel('num principal components')
matplotlib.pyplot.ylabel('Fraction of total variance explained')

n_components = 3

pca = PCA(n_components=n_components).fit(trainSet)

X_train_pca = pca.transform(trainSet)
X_test_pca = pca.transform(testSet)

fig, ax = matplotlib.pyplot.subplots(1)

for i in range(2):
    ax.scatter(X_train_pca[trainRes==i][:,0], X_train_pca[trainRes==i][:,1], label=[0, 1][i], alpha=0.5)
    
ax.set_xlabel('PC 1')
ax.set_xlabel('PC 2')
ax.legend()

X_train_pca

len(X_train_pca)

trainRes = trainRes.astype('int')

from sklearn.svm import SVC
svc = SVC(C=10000, kernel='rbf')
svc.fit(X_train_pca, trainRes)

y_pred = svc.predict(X_test_pca)

testRes = testRes.astype('int')

from sklearn.metrics import classification_report

print(classification_report(testRes, y_pred))

print("SVM PCA")
fscore=calculatefscore(testRes,y_pred)

lgbmClassifier=lightgbm.LGBMClassifier()
lgbmClassifier.fit(X_train_pca, trainRes)
predLGBM = lgbmClassifier.predict(X_test_pca)

print(classification_report(testRes, predLGBM))

print("LGBM PCA")
fscore=calculatefscore(testRes,predLGBM)

decisionTreeClassifier=sklearn.tree.DecisionTreeClassifier()
decisionTreeClassifier.fit(X_train_pca, trainRes)
predDTC = decisionTreeClassifier.predict(X_test_pca)
print(classification_report(testRes, predDTC))

print("Decision Tree PCA")
fscore=calculatefscore(testRes,predDTC)

xgBoostClassfier = xgboost.XGBClassifier()
xgBoostClassfier.fit(X_train_pca, trainRes)
predictionsXGBoost = xgBoostClassfier.predict(X_test_pca)
print(classification_report(testRes, predictionsXGBoost))

print("XGBoost Classifier PCA")
fscore=calculatefscore(testRes,predictionsXGBoost)

randomForestClassifier = sklearn.ensemble.RandomForestClassifier()
randomForestClassifier.fit(X_train_pca, trainRes)
predictionsRandomForest = randomForestClassifier.predict(X_test_pca)
print(classification_report(testRes, predictionsRandomForest))

print("Random Forest PCA")
fscore=calculatefscore(testRes,predictionsRandomForest)

from sklearn.decomposition import KernelPCA

n_components = 10

kpca = KernelPCA(n_components=n_components, kernel='rbf', fit_inverse_transform=True).fit(trainSet)

X_train_kpca = kpca.transform(trainSet)
X_test_kpca = kpca.transform(testSet)

fig, ax = matplotlib.pyplot.subplots(1)

for i in range(2):
    ax.scatter(X_train_kpca[trainRes==i][:,0], X_train_kpca[trainRes==i][:,1], label=[0, 1][i], alpha=0.5)
    
ax.set_xlabel('PC 1')
ax.set_xlabel('PC 2')
ax.legend()

svc = SVC(C=10000, kernel='rbf')
svc.fit(X_train_kpca, trainRes)
y_pred_svm = svc.predict(X_test_kpca)
print(classification_report(testRes, y_pred_svm))

print("SVM Kernel PCA")
fscore=calculatefscore(testRes,y_pred_svm)

lgbmClassifier=lightgbm.LGBMClassifier()
lgbmClassifier.fit(X_train_kpca, trainRes)
predLGBMKpca = lgbmClassifier.predict(X_test_kpca)

print(classification_report(testRes, predLGBMKpca))

print('LGBM Kernel PCA')
fscore=calculatefscore(testRes,predLGBMKpca)

decisionTreeClassifier=sklearn.tree.DecisionTreeClassifier()
decisionTreeClassifier.fit(X_train_kpca, trainRes)
predDTCKpca = decisionTreeClassifier.predict(X_test_kpca)
print(classification_report(testRes, predDTCKpca))

print('Decision Tree Classifier Kernel PCA')
fscore=calculatefscore(testRes,predDTCKpca)

xgBoostClassfier = xgboost.XGBClassifier()
xgBoostClassfier.fit(X_train_kpca, trainRes)
predictionsXGBoostKpca = xgBoostClassfier.predict(X_test_kpca)
print(classification_report(testRes, predictionsXGBoostKpca))

print('XGBoost Kernel PCA')
fscore=calculatefscore(testRes,predictionsXGBoostKpca)

randomForestClassifier = sklearn.ensemble.RandomForestClassifier()
randomForestClassifier.fit(X_train_kpca, trainRes)
predictionsRandomForestKpca = randomForestClassifier.predict(X_test_kpca)
print(classification_report(testRes, predictionsRandomForestKpca))

print('Random Forest Kernel PCA')
fscore=calculatefscore(testRes,predictionsRandomForestKpca)

lda = LinearDiscriminantAnalysis()
X_train_lda = lda.fit_transform(trainSet, trainRes)

X_test_lda = lda.transform(testSet)

svc = SVC(C=10000, kernel='rbf')
svc.fit(X_train_lda, trainRes)
y_pred_svmlda = svc.predict(X_test_lda)
print(classification_report(testRes, y_pred_svmlda))

print("SVM LDA")
fscore=calculatefscore(testRes,y_pred_svmlda)

lgbmClassifier=lightgbm.LGBMClassifier()
lgbmClassifier.fit(X_train_lda, trainRes)
predLGBMLda = lgbmClassifier.predict(X_test_lda)
print(classification_report(testRes, predLGBMLda))

print("LGBM LDA")
fscore=calculatefscore(testRes,predLGBMLda)

decisionTreeClassifier=sklearn.tree.DecisionTreeClassifier()
decisionTreeClassifier.fit(X_train_lda, trainRes)
predDTCLda = decisionTreeClassifier.predict(X_test_lda)
print(classification_report(testRes, predDTCLda))

print("Decision Tree Classifier LDA")
fscore=calculatefscore(testRes,predDTCLda)

xgBoostClassfier = xgboost.XGBClassifier()
xgBoostClassfier.fit(X_train_lda, trainRes)
predictionsXGBoostLda = xgBoostClassfier.predict(X_test_lda)
print(classification_report(testRes, predictionsXGBoostLda))

print("XGBoost LDA")
fscore=calculatefscore(testRes,predictionsXGBoostLda)

randomForestClassifier = sklearn.ensemble.RandomForestClassifier()
randomForestClassifier.fit(X_train_lda, trainRes)
predictionsRandomForestLda = randomForestClassifier.predict(X_test_lda)
print(classification_report(testRes, predictionsRandomForestLda))

print('Random Forest LDA')
fscore=calculatefscore(testRes,predictionsRandomForestLda)